---
title: "Variograms and Model Selection"
author: "Chris H. Fleming and Justin M. Calabrese"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteKeyword{variogram}
  %\VignetteIndexEntry{Variograms and Model Selection}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

In this vignette, we walk through data preparation, variogram analysis, and maximum likelihood estimation.

# Data Preparation

The first step is to import your MoveBank csv file:

```
yourAnimals <- as.telemetry("yourAnimalsMoveBank.csv")
```

Alternatively, if you want to clean your csv file first, you can import it as a data frame

```
yourAnimalsDF <- read.csv("yourAnimalsMoveBank.csv")
```

and then edit the data frame before converting it into a `telemetry` object for `ctmm` via

```
yourAnimals <- as.telemetry(yourAnimalsDF)
```

For most species, the default two-point equidistant projection will be fine, however you can provide any PROJ.4 formatted projection with the `projection` argument (see `help(as.telemetry)`). A single fixed projection should be used if you are going to plot groups of individuals that span multiple MoveBank files. This is done by default if multiple individuals are included in a single data frame.

The output of `as.telemetry` will be an individual `telemetry` object or list of `telemetry` objects, depending on how many individual animals are in your csv file. `telemetry` objects contain the components `t` for time in seconds, and `x` and `y` for the projected locations in meters. Times in your MoveBank file should be sorted and non-repeating.

Our example buffalo data is already prepared into a list of `telemetry` objects.
Let us look at the first buffalo and then every buffalo:

```{r,  fig.show='hold'}
library(ctmm)
data("buffalo")
cilla <- buffalo[[1]]
plot(cilla)
title("1 Buffalo")
plot(buffalo,col=rainbow(length(buffalo)),alpha=c(0.5,0.05))
title("5 Buffalo")
```

Looking at the raw movement tracks is a good way to pick out any obvious migratory behaviors.
In the future, we will have migration models to select, but for now all of our models are range resident and so only those portions of the data should be selected.
These buffalo all look fairly range resident, and so we can move on to variograms.

# Variograms

Variograms are an unbiased way to visualize autocorrelation structure when migration, range shifting, drift, or other translations of the mean location are not happening. When drift occurs in the data, then the variogram represents a mixture of both the drift and the autocorrelation structure, each of which contains distinct movement behaviors. In the future, we will have models that can allow for drift, but the current models assume range residence, which we can check with the variogram.

```{r,  fig.show='hold'}
svf <- variogram(cilla)
plot(svf,fraction=0.005)
title("zoomed in")
plot(svf,fraction=0.65,alpha=c(0.5,0.05))
title("zoomed out")
```

The first plot is zoomed in to the short lag behavior, while the second plot is zoomed out.
You can do this on the fly with `zoom(cilla)` in R-studio. The variogram represents the average square distance traveled (vertical axis) within some time lag (horizontal axis).

For the long range behavior we can see that the variogram flattens (asymptotes) at approximately 20 days. This is, roughly, how coarse you need to make the timeseries so that methods assuming independence (no autocorrelation) can be valid. This includes, conventional kernel density estimation (KDE), minimum convex polygon (MCP), conventional species distribution modeling (SDM), and a host of other analyses.

The asymptote of our variogram is around 23 square km, and the fact that it takes roughly 20 days for the variogram to asymptote is indicative of the fact that the buffalo's location appears continuous at this timescale. This is also, roughly, the time it takes for the buffalo to cross its home range. We can guesstimate some continuous-time models for this behavior with the commands

```{r,  fig.show='hold'}
m0 <- ctmm(sigma=23*1000^2) # 23 km^2 in m^2
m1 <- ctmm(sigma=23*1000^2,tau=6*24*60^2) # and 6 days in seconds
plot(svf,CTMM=m0,fraction=0.65,alpha=c(0.5,0.05),col.CTMM="red")
title("m0")
plot(svf,CTMM=m1,fraction=0.65,alpha=c(0.5,0.05),col.CTMM="purple")
title("m1")
```

where for both the models `m0` and `m1`, `sigma` is the asymptotic variance. In model `m1`, `tau` is a single timescale that governs the autocorrelation in position and dictates the animal's home-range crossing time. The null model `m0` has no autocorrelation. Notice that all units are in meters and seconds.

The uncorrelated model `m0` is obviously incorrect and in the zoomed in plot we can also see that the model `m1` is incorrectly linear at short lags, whereas the empirical variogram actually curves up for an hour or two before it becomes linear. Let us introduce a model that incorporates this behavior.

```{r,  fig.show='hold'}
m2 <- ctmm(sigma=23*1000^2,tau=c(6*24*60^2,1*60^2)) # and 1 hour in seconds
plot(svf,CTMM=m1,fraction=0.002,col.CTMM="purple")
title("m1")
plot(svf,CTMM=m2,fraction=0.002,col.CTMM="blue")
title("m2")
```

The confidence intervals at short lags are also very narrow, though both of these models look the same at coarser scales and so the discrepancy is only revealed by high resolution data.

```{r,  fig.show='hold'}
plot(svf,CTMM=m1,fraction=0.65,alpha=c(0.5,0.05),col.CTMM="purple")
title("m1")
plot(svf,CTMM=m2,fraction=0.65,alpha=c(0.5,0.05),col.CTMM="blue")
title("m2")
```

The model `m2` introduces an additional autocorrelation timescale for the animal's velocity, so that it more closely matches the initial behavior of the variogram. The initial curve upwards tells us that there is continuity in the animal's velocity at this timescale. Conventional Markovian animal movement models do not capture this, which leads to the same kind of bias and underestimation of confidence intervals as when ignoring autocorrelation entirely.

The linear regime of the variogram (regular diffusion) is just as important as the asymptotic regime. In the linear regime it is reasonable to assume a Markovian model as with step selection functions (SSF) and Brownian bridges (BB). Therefore, the variogram has informed us as to how much we need to coarsen our data for it to be appropriate in many common analyses that neglect various aspects of movement.

Finally, the R-studio function `variogram.fit(svf)` is much easier to use than guestimating the model parameters by hand as we did above. `variogram.fit` gives you sliders to choose the most visually appropriate parameters and save them to a global variable (`global.variogram.fit` by default).

### Variogram Error is Autocorrelated

It is important to note that variogram errors---the difference between the empirical variogram and the true semi-variance function---are themselves autocorrelated. Therefore, the smooth wiggling around that the point estimate does within the confidence bands is not necessarily meaningful. To demonstrate this, let us simulate some data from the model `m2` and look at its empirical variogram.

```{r,  fig.show='hold'}
# simulate fake buffalo with the same sampling schedule
willa <- simulate(m2,t=cilla$t)
plot(willa)
title("simulation")
# now calculate and plot its variogram
svf2 <- variogram(willa)
plot(svf2,CTMM=m2,fraction=0.65,alpha=c(0.5,0.05),col.CTMM="blue")
title("simulation")
```

### Irregular Sampling Schedules

Random gaps in the data are acceptable and fully accounted for in both variogram estimation and model fitting.
However, if under any condition the sampling rate changes during data collection, then you will have to account for that in the varioram with the \code{dt} argument. In the followng example, the collar was programed to cycle between 1, 5, 25 hour sampling intervals

```{r, fig.show='hold'}
data("gazelle")
svf3 <- variogram(gazelle[[18]],fast=TRUE)
plot(svf3,fraction=0.85,alpha=c(0.5,0.05))
title("Default method")
# 1, 5, 25 hour sampling intervals
dt <- 60*60*c(1,5,25)
svf3 <- variogram(gazelle[[18]],dt=dt,fast=TRUE)
plot(svf3,fraction=0.85,alpha=c(0.5,0.05))
title("Multi method")
```

### Pooling Variograms

If multiple individuals exhibit similar movement behaviors, then we can pool their individual variograms to create a more precise population variogram. You should be careful though, if the individual movement behaviors and sampling schedules are not identical, then there will be discontinuities at lags where one timeseries runs out of data.

```{r, fig.show='hold'}
# 1 hour sampling intervals
dt = 60*60
# buffalo 4 is bad
svf4 <- lapply(buffalo[-4],function(b){ variogram(b,dt=dt,fast=TRUE) })
svf4 <- mean(svf4)
plot(svf4,fraction=0.35,alpha=c(0.5,0.05))
title("Population variogram")
```

### Non-Stationarity in Stationary Variograms

Non-stationary behaviors, like a seasonal change in variance, is averaged over in the variogram. Moreover, if we fit a stationary model to non-stationary data, we are estimating an average effect. For instance, if an animal rests at night and diffuses at some rate `D` during the day, then without modeling the rest behavior we estimate an average of zero and `D`. Its not terribly detrimental to average over frequently repeated non-stationarity, but if an animal migrates once in a dataset then this behavior really needs to be included in the model. These kinds of models will be included in future versions of `ctmm`.

## More Models

### Telemetry Error

The GPS buffalo example do not exhibit telemetry errors that are significant enough to notice in our variograms. If we were working with ARGOS data or the high-resolution and unfiltered GPS data of a small animal, then we get a "nugget" effect that looks like an initial discontinuity at short time lags.

```{r,  fig.show='hold', echo=FALSE}
# ARGOS type errors
curve(1+x,0,5,xlab="Short time lag",ylab="Semi-variance",ylim=c(0,6))
points(c(0,0),c(0,1))
title("ARGOS")
# detector array type errors (qualitatively only)
curve((1-exp(-2*x))/(1-exp(-2/4)),0,1/4,xlab="Short time lag",ylab="Semi-variance",ylim=c(0,6),xlim=c(0,5),add=FALSE)
curve(3/4+x,1/4,5,xlab="Short time lag",ylab="Semi-variance",ylim=c(0,6),add=TRUE,xlim=c(0,5))
points(1/4,1)
title("Detector Array")
```

The height of this initial discontinuity corresponds to the variance of uncorrelated location errors. You will soon be able to incorporate these kinds of errors into `ctmm` analysis.

The second plot is a depiction of the kind of initial discontinuity one has with detector array data. The end of the (slope) discontinuity is highlighted with a circle. This discontinuity is smooth because the movement and detection are correlated. The height of this initial discontinuity is also (at least roughly) the variance of the location errors.

### Cycles and Periodicities

### One-Off Migrations

### Repeated Migrations

# Model Fitting

Now let us fit each of our proposed models `m0`, `m1`, `m2`, store the corresponding best-fit result in `M0`, `M1`, `M2`, and then compare some of their outputs.

```{r,  fig.show='hold'}
M0 <- ctmm.fit(cilla,m0)
summary(M0)
```

```{r,  fig.show='hold'}
M1 <- ctmm.fit(cilla,m1)
summary(M1)
```

```{r,  fig.show='hold'}
M2 <- ctmm.fit(cilla,m2)
summary(M2)
```

Notice how tiny the (Gaussian) area uncertainty is in model `M0`. Let us look into some details of the models.

```{r,  fig.show='hold'}
TAB <- rbind( c(M0$AICc,M0$DOF.mu) , c(M1$AICc,M1$DOF.mu) , c(M2$AICc,M2$DOF.mu) )
colnames(TAB) <- c("AICc","DOF(mu)")
rownames(TAB) <- c("M0","M1","M2")
TAB
```

`AICc` is the (linearly) corrected Akaike information criteria. AIC balances likelihood against model complexity in a way that is good if we want to make optimal predictions. A lower AIC is better. Getting the AIC to go down by 5 is great, while getting the AIC to go down by 10 is awesome. Our AIC is going down by thousands.

The fit parameter `DOF.mu` is the number of degrees of freedom worth of data we have to estimate the mean parameter `mu`, assuming that the model is correct. Notice that the uncorrelated model `M0` perceives thousands of independent data points, while the autocorrelated models `M1` and `M2` only see a handful of independent data points. This is why the uncorrelated model produced tiny confidence intervals on the predicted (Gaussian) area.

## Back to the Variogram

Now its time to make sure that our selected model is explaining the most significant features of the animal's movement. Let us plot our variogram again with our fit models

```{r,  fig.show='hold'}
plot(svf,CTMM=list(M0,M1,M2),col.CTMM=c("red","purple","blue"),fraction=0.65,alpha=0.5)
title("zoomed out")
plot(svf,CTMM=list(M0,M1,M2),col.CTMM=c("red","purple","blue"),fraction=0.002,alpha=0.5)
title("zoomed in")
```

Notice that the purple model `M1` is significantly biased downward and is underestimating diffusion. This is because the continuous-velocity behavior at short time lags, which `M1` does not account for, is throwing off the estimate. `M0` is ignoring autocorrelation completely, while `M1` is ignoring autocorrelation in the buffalo's velocity.